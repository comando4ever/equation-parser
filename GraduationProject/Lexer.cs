/* The following code was generated by CSFlex 1.4 on 3/2/2015 */
#line 1 "/home/comando/Desktop/Lexer"
using System;
using System.IO;

namespace GraduationProject
{

	public enum TokenType
	{
		ADD,
		SUB,
		DEV,
		MULTI,
		POW,
		FACT,
		LPARENT,
		RPARENT,
		EQUAL,
		SIN,
		COS,
		LOG,
		TAN,
		EXP,
		SINH,
		COSH,
		TANH,
		SQRT,
		LN,
		PI,
		MOD,
		ROOT,
		NUM,
		VAR,
		ERROR,
		EOF
	}

	public class Token
	{
		public string text;
		public int begin;
		public int end;
		public TokenType type;

		public Token (TokenType type, String text, int begin, int end)
		{
			this.type = type;
			this.text = text;
			this.begin = begin;
			this.end = end;
		}

		public override string ToString ()
		{
			return String.Format ("[{0}, {1}, {2}, {3}]", type, text, begin, end);
		}
	}

	#line default
	/**
 * This class is a scanner generated by <a href="http://www.sourceforge.net/projects/csflex/">C# Flex</a>, based on
 * <a href="http://www.jflex.de/">JFlex</a>, version 1.4
 * on 3/2/2015 from the specification file
 * <tt>/home/comando/Desktop/Lexer</tt>
 */
	public class Lexer
	{
		/** This character denotes the end of file */
		public const int YYEOF = -1;

		/** initial size of the lookahead buffer */
		private const int ZZ_BUFFERSIZE = 16384;
		/**
   * This is used in 'if' statements to eliminate dead code
   * warnings for 'break;' after the end of a user action
   * block of code. The Java version does this by emitting
   * a second 'case' which is impossible to reach. Since this
   * is impossible for the compiler to deduce during semantic
   * analysis, the warning is stifled. However, C# does not
   * permit 'case' blocks to flow into each other, so the C#
   * output mode needs a different approach. In this case,
   * the entire user code is wrapped up in an 'if' statement
   * whose condition is always true. No warning is emitted
   * because the compiler doesn't strictly propagate the value
   * of 'static readonly' fields, and thus does not semantically
   * detect the fact that the 'if' will always be true.
   */
		public static readonly bool ZZ_SPURIOUS_WARNINGS_SUCK = true;

		/** lexical states */
		public const int YYINITIAL = 0;

		static Lexer ()
		{
			ZZ_ACTION = zzUnpackAction ();
			ZZ_ROWMAP = zzUnpackRowMap ();
			ZZ_TRANS = zzUnpackTrans ();
			ZZ_ATTRIBUTE = zzUnpackAttribute ();
		}


		/** 
   * Translates characters to character classes
   */
		private static readonly char[] ZZ_CMAP = new char[] {
			(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)3, (char)3, (char)0, (char)3, (char)3, (char)0, (char)0, 
			(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, 
			(char)3, (char)10, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)11, (char)12, (char)6, (char)7, (char)0, (char)8, (char)31, (char)5, 
			(char)1, (char)2, (char)2, (char)2, (char)2, (char)2, (char)2, (char)2, (char)2, (char)2, (char)0, (char)0, (char)0, (char)4, (char)0, (char)0, 
			(char)0, (char)21, (char)32, (char)16, (char)30, (char)24, (char)32, (char)19, (char)22, (char)14, (char)32, (char)32, (char)18, (char)29, (char)15, (char)17, 
			(char)26, (char)27, (char)28, (char)13, (char)20, (char)32, (char)32, (char)32, (char)25, (char)32, (char)32, (char)0, (char)0, (char)0, (char)9, (char)0, 
			(char)0, (char)21, (char)32, (char)16, (char)30, (char)23, (char)32, (char)19, (char)22, (char)14, (char)32, (char)32, (char)18, (char)29, (char)15, (char)17, 
			(char)26, (char)27, (char)28, (char)13, (char)20, (char)32, (char)32, (char)32, (char)25, (char)32, (char)32, (char)0, (char)0, (char)0, (char)0, (char)0
		};

		/** 
   * Translates DFA states to action switch labels.
   */
		private static readonly int[] ZZ_ACTION;

		private static readonly ushort[] ZZ_ACTION_PACKED_0 = new ushort[] {
			1, 1, 1, 2, 2, 3, 1, 1, 1, 4, 1, 5, 1, 6, 1, 7,
			1, 8, 1, 9, 1, 10, 1, 11, 1, 12, 5, 13, 1, 14, 4, 13,
			1, 0, 3, 13, 1, 15, 3, 13, 1, 16, 2, 13, 2, 3, 1, 17,
			1, 13, 1, 18, 1, 19, 1, 20, 1, 14, 1, 13, 1, 21, 1, 22,
			1, 23, 1, 24, 1, 25, 1, 26, 0
		};

		private static int [] zzUnpackAction ()
		{
			int[] result = new int[50];
			int offset = 0;
			offset = zzUnpackAction (ZZ_ACTION_PACKED_0, offset, result);
			return result;
		}

		private static int zzUnpackAction (ushort[] packed, int offset, int[] result)
		{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i + 1 < l) {
				int count = packed [i++];
				int value = packed [i++];
				do
					result [j++] = value;
				while (--count > 0);
			}
			return j;
		}


		/** 
   * Translates a state to a row index in the transition table
   */
		private static readonly int[] ZZ_ROWMAP;

		private static readonly ushort[] ZZ_ROWMAP_PACKED_0 = new ushort[] {
			0, 0, 0, 33, 0, 66, 0, 99, 0, 132, 0, 33, 0, 33, 0, 33,
			0, 33, 0, 33, 0, 33, 0, 33, 0, 33, 0, 33, 0, 165, 0, 198,
			0, 231, 0, 0x0108, 0, 0x0129, 0, 0x014a, 0, 0x014a, 0, 0x016b, 0, 0x018c, 0, 0x01ad,
			0, 0x01ce, 0, 0x01ef, 0, 0x0210, 0, 0x0231, 0, 198, 0, 0x0252, 0, 0x0273, 0, 0x0294,
			0, 198, 0, 0x02b5, 0, 0x02d6, 0, 33, 0, 0x02f7, 0, 0x0318, 0, 0x0339, 0, 0x035a,
			0, 198, 0, 0x037b, 0, 198, 0, 0x039c, 0, 198, 0, 198, 0, 198, 0, 198,
			0, 198, 0, 198, 0
		};

		private static int [] zzUnpackRowMap ()
		{
			int[] result = new int[50];
			int offset = 0;
			offset = zzUnpackRowMap (ZZ_ROWMAP_PACKED_0, offset, result);
			return result;
		}

		private static int zzUnpackRowMap (ushort[] packed, int offset, int[] result)
		{
			int i = 0;  /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i + 1 < l) {
				int high = packed [i++] << 16;
				result [j++] = high | packed [i++];
			}
			return j;
		}

		/** 
   * The transition table of the DFA
   */
		private static readonly int[] ZZ_TRANS;

		private static readonly ushort[] ZZ_TRANS_PACKED_0 = new ushort[] {
			1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
			1, 10, 1, 11, 1, 12, 1, 13, 1, 14, 1, 15, 2, 16, 1, 17,
			1, 16, 1, 18, 1, 16, 1, 19, 2, 16, 1, 20, 1, 21, 1, 16,
			1, 22, 1, 16, 1, 23, 1, 24, 1, 16, 1, 2, 1, 16, 64, 0,
			1, 25, 2, 0, 2, 4, 28, 0, 1, 25, 4, 0, 1, 5, 30, 0,
			2, 16, 10, 0, 1, 16, 1, 26, 12, 16, 1, 27, 3, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 18, 16, 1, 0, 1, 16, 1, 0,
			2, 16, 10, 0, 4, 16, 1, 28, 13, 16, 1, 0, 1, 16, 1, 0,
			2, 16, 10, 0, 2, 16, 1, 29, 1, 16, 1, 30, 13, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 8, 16, 1, 31, 9, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 12, 16, 1, 32, 5, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 1, 16, 1, 33, 16, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 4, 16, 1, 34, 13, 16, 1, 0,
			1, 16, 1, 0, 2, 16, 10, 0, 4, 16, 1, 35, 13, 16, 1, 0,
			1, 16, 1, 0, 1, 36, 1, 37, 31, 0, 2, 16, 10, 0, 2, 16,
			1, 38, 15, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 15, 16,
			1, 39, 2, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 1, 40,
			17, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 6, 16, 1, 41,
			11, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 2, 16, 1, 42,
			15, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 13, 16, 1, 43,
			4, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 4, 16, 1, 44,
			13, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 17, 16, 1, 45,
			1, 0, 1, 16, 1, 0, 2, 37, 31, 0, 2, 16, 10, 0, 9, 16,
			1, 46, 8, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 7, 16,
			1, 47, 10, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 9, 16,
			1, 48, 8, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 9, 16,
			1, 49, 8, 16, 1, 0, 1, 16, 1, 0, 2, 16, 10, 0, 7, 16,
			1, 50, 10, 16, 1, 0, 1, 16, 0
		};

		private static int [] zzUnpackTrans ()
		{
			int[] result = new int[957];
			int offset = 0;
			offset = zzUnpackTrans (ZZ_TRANS_PACKED_0, offset, result);
			return result;
		}

		private static int zzUnpackTrans (ushort[] packed, int offset, int[] result)
		{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i + 1 < l) {
				int count = packed [i++];
				int value = packed [i++];
				value--;
				do
					result [j++] = value;
				while (--count > 0);
			}
			return j;
		}


		/* error codes */
		private const int ZZ_UNKNOWN_ERROR = 0;
		private const int ZZ_NO_MATCH = 1;
		private const int ZZ_PUSHBACK_2BIG = 2;

		/* error messages for the codes above */
		private static readonly String[] ZZ_ERROR_MSG = new string[] {
			"Unkown internal scanner error",
			"Error: could not match input",
			"Error: pushback value was too large"
		};

		/**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
		private static readonly int[] ZZ_ATTRIBUTE;

		private static readonly ushort[] ZZ_ATTRIBUTE_PACKED_0 = new ushort[] {
			1, 1, 1, 9, 3, 1, 9, 9, 10, 1, 1, 0, 10, 1, 1, 9,
			14, 1, 0
		};

		private static int [] zzUnpackAttribute ()
		{
			int[] result = new int[50];
			int offset = 0;
			offset = zzUnpackAttribute (ZZ_ATTRIBUTE_PACKED_0, offset, result);
			return result;
		}

		private static int zzUnpackAttribute (ushort[] packed, int offset, int[] result)
		{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i + 1 < l) {
				int count = packed [i++];
				int value = packed [i++];
				do
					result [j++] = value;
				while (--count > 0);
			}
			return j;
		}

		/** the input device */
		private System.IO.TextReader zzReader;

		/** the current state of the DFA */
		private int zzState;

		/** the current lexical state */
		private int zzLexicalState = YYINITIAL;

		/** this buffer contains the current text to be matched and is
      the source of the yytext() string */
		private char[] zzBuffer = new char[ZZ_BUFFERSIZE];

		/** the textposition at the last accepting state */
		private int zzMarkedPos;

		/** the textposition at the last state to be included in yytext */
		private int zzPushbackPos;

		/** the current text position in the buffer */
		private int zzCurrentPos;

		/** startRead marks the beginning of the yytext() string in the buffer */
		private int zzStartRead;

		/** endRead marks the last character in the buffer, that has been read
      from input */
		private int zzEndRead;

		/** number of newlines encountered up to the start of the matched text */
		private int yyline;

		/** the number of characters up to the start of the matched text */
		private int yychar;

		/**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
		private int yycolumn;

		/** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
		private bool zzAtBOL = true;

		/** zzAtEOF == true <=> the scanner is at the EOF */
		private bool zzAtEOF;


		/**
   * Creates a new scanner
   * There is also a System.IO.Stream version of this constructor.
   *
   * @param   in  the System.IO.TextReader to read input from.
   */
		public Lexer (TextReader @in)
		{
			this.zzReader = @in;
		}

		/**
   * Creates a new scanner.
   * There is also TextReader version of this constructor.
   *
   * @param   in  the System.IO.Stream to read input from.
   */
		public Lexer (Stream @in) : this (new StreamReader (@in))
		{
		}


		/**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   IOException  if any I/O-Error occurs
   */
		private bool zzRefill ()
		{

			/* first: make room (if you can) */
			if (zzStartRead > 0) {
				Array.Copy (zzBuffer, zzStartRead,
					zzBuffer, 0,
					zzEndRead - zzStartRead);

				/* translate stored positions */
				zzEndRead -= zzStartRead;
				zzCurrentPos -= zzStartRead;
				zzMarkedPos -= zzStartRead;
				zzPushbackPos -= zzStartRead;
				zzStartRead = 0;
			}

			/* is the buffer big enough? */
			if (zzCurrentPos >= zzBuffer.Length) {
				/* if not: blow it up */
				char[] newBuffer = new char[zzCurrentPos * 2];
				Array.Copy (zzBuffer, 0, newBuffer, 0, zzBuffer.Length);
				zzBuffer = newBuffer;
			}

			/* finally: fill the buffer with new input */
			int numRead = zzReader.Read (zzBuffer, zzEndRead,
				              zzBuffer.Length - zzEndRead);

			if (numRead <= 0) {
				return true;
			} else {
				zzEndRead += numRead;
				return false;
			}
		}

    
		/**
   * Closes the input stream.
   */
		public void yyclose ()
		{
			zzAtEOF = true;            /* indicate end of file */
			zzEndRead = zzStartRead;  /* invalidate buffer    */

			//if (zzReader != null)
			//zzReader.Close();
		}


		/**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
		public void yyreset (System.IO.TextReader reader)
		{
			zzReader = reader;
			zzAtBOL = true;
			zzAtEOF = false;
			zzEndRead = zzStartRead = 0;
			zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
			yyline = yychar = yycolumn = 0;
			zzLexicalState = YYINITIAL;
		}


		/**
   * Returns the current lexical state.
   */
		public int yystate ()
		{
			return zzLexicalState;
		}


		/**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
		public void yybegin (int newState)
		{
			zzLexicalState = newState;
		}


		/**
   * Returns the text matched by the current regular expression.
   */
		public String yytext ()
		{
			return new String (zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
		}


		/**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
		public char yycharat (int pos)
		{
			return zzBuffer [zzStartRead + pos];
		}


		/**
   * Returns the length of the matched text region.
   */
		public int yylength ()
		{
			return zzMarkedPos - zzStartRead;
		}


		/**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex/CSFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
		private void zzScanError (int errorCode)
		{
			String message;
			try {
				message = ZZ_ERROR_MSG [errorCode];
			} catch (IndexOutOfRangeException) {
				message = ZZ_ERROR_MSG [ZZ_UNKNOWN_ERROR];
			}

			throw new Exception (message);
		}


		/**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
		public void yypushback (int number)
		{
			if (number > yylength ())
				zzScanError (ZZ_PUSHBACK_2BIG);

			zzMarkedPos -= number;
		}


		/**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   System.IO.IOException  if any I/O-Error occurs
   */
		public Token getNextToken ()
		{
			int zzInput = 0;
			int zzAction;

			// cached fields:
			int zzCurrentPosL;
			int zzMarkedPosL;
			int zzEndReadL = zzEndRead;
			char[] zzBufferL = zzBuffer;
			char[] zzCMapL = ZZ_CMAP;

			int[] zzTransL = ZZ_TRANS;
			int[] zzRowMapL = ZZ_ROWMAP;
			int[] zzAttrL = ZZ_ATTRIBUTE;

			while (true) {
				zzMarkedPosL = zzMarkedPos;

				yychar += zzMarkedPosL - zzStartRead;

				bool zzR = false;
				for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                                                             zzCurrentPosL++) {
					switch (zzBufferL [zzCurrentPosL]) {
					case '\u000B':
					case '\u000C':
					case '\u0085':
					case '\u2028':
					case '\u2029':
						yyline++;
						zzR = false;
						break;
					case '\r':
						yyline++;
						zzR = true;
						break;
					case '\n':
						if (zzR)
							zzR = false;
						else {
							yyline++;
						}
						break;
					default:
						zzR = false;
						break;
					}
				}

				if (zzR) {
					// peek one character ahead if it is \n (if we have counted one line too much)
					bool zzPeek;
					if (zzMarkedPosL < zzEndReadL)
						zzPeek = zzBufferL [zzMarkedPosL] == '\n';
					else if (zzAtEOF)
						zzPeek = false;
					else {
						bool eof = zzRefill ();
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						if (eof)
							zzPeek = false;
						else
							zzPeek = zzBufferL [zzMarkedPosL] == '\n';
					}
					if (zzPeek)
						yyline--;
				}
				zzAction = -1;

				zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
				zzState = zzLexicalState;


				while (true) {
					goto zzForAction_skip;
					zzForAction:
					break;
					zzForAction_skip:
					if (!ZZ_SPURIOUS_WARNINGS_SUCK)
						goto zzForAction;
    
					if (zzCurrentPosL < zzEndReadL)
						zzInput = zzBufferL [zzCurrentPosL++];
					else if (zzAtEOF) {
						zzInput = YYEOF;
						goto zzForAction;
					} else {
						// store back cached positions
						zzCurrentPos = zzCurrentPosL;
						zzMarkedPos = zzMarkedPosL;
						bool eof = zzRefill ();
						// get translated positions and possibly new buffer
						zzCurrentPosL = zzCurrentPos;
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						zzEndReadL = zzEndRead;
						if (eof) {
							zzInput = YYEOF;
							goto zzForAction;
						} else {
							zzInput = zzBufferL [zzCurrentPosL++];
						}
					}
					int zzNext = zzTransL [zzRowMapL [zzState] + zzCMapL [zzInput]];
					if (zzNext == -1)
						goto zzForAction;
					zzState = zzNext;

					int zzAttributes = zzAttrL [zzState];
					if ((zzAttributes & 1) == 1) {
						zzAction = zzState;
						zzMarkedPosL = zzCurrentPosL;
						if ((zzAttributes & 8) == 8)
							goto zzForAction;
					}

				}

				// store back cached position
				zzMarkedPos = zzMarkedPosL;

				switch (zzAction < 0 ? zzAction : ZZ_ACTION [zzAction]) {
				case 1: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 56 "/home/comando/Desktop/Lexer"
                  
#line default
					}
					break;
				case 9: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 37 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.POW, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 19: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 43 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.LOG, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 2: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 57 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.ERROR, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 26: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 53 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.PI, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 24: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 46 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.COSH, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 12: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 40 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.RPARENT, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 11: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 39 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.LPARENT, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 8: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 36 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.SUB, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 21: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 52 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.MOD, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 23: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 49 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.SQRT, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 5: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 33 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.DEV, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 18: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 42 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.COS, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 14: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 48 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.EXP, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 16: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 51 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.PI, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 25: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 47 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.TANH, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 6: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 34 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.MULTI, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 13: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 55 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.VAR, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 20: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 44 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.TAN, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 17: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 41 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.SIN, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 7: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 35 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.ADD, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 4: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 32 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.EQUAL, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 22: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 45 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.SINH, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 10: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 38 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.FACT, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 3: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 54 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.NUM, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				case 15: 
					if (ZZ_SPURIOUS_WARNINGS_SUCK) {
#line 50 "/home/comando/Desktop/Lexer"
						return new Token (TokenType.LN, yytext (), yychar, yychar + yytext ().Length);
#line default
					}
					break;
				default: 
					if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
						zzAtEOF = true;
						return null;
					} else {
						zzScanError (ZZ_NO_MATCH);
					}
					break;
				}
			}
		}

	}
}